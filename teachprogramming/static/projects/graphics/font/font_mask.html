<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,....==" />
</head>
<body></body>
<script type="module">
import {CanvasAnimationBase} from './animation_base.js'

function* range(target, start=0, step=1) {for (let i=start ; i<target ; i+=step) {yield i}}
function* enumerate(iterable) {let count = 0; for (let item of iterable) {yield [count++, item]}}
function clear_object(o) {Object.keys(o).forEach(k => {delete o[k]})}


const SEQUENCE_DAMIENG = ` !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_£abcdefghijklmnopqrstuvwxyz{|}~©`


class Surface {
    constructor(width, height) {
        if (!(Number.isInteger(width) && Number.isInteger(height))) {debugger}
        console.assert(Number.isInteger(width) && Number.isInteger(height), "Surface must have int width/height")
        this.o = new OffscreenCanvas(width, height)
        this._c = this.o.getContext("2d")
        this._img = undefined
    }
    get w() {return this.o.width}
    get h() {return this.o.height}
    get c() {this._img = undefined; return this._c}
    get img() {return this._img || (this._img = this.o.transferToImageBitmap())}
    clear() {this.c.clearRect(0, 0, this.w, this.h)}
    static isDimensionMatch(a, b) {return a.w==b.w && a.h==b.h}
    static fromCanvas(canvas) {
        const s = new Surface(canvas.width, canvas.height)
        s.c.drawImage(canvas,0,0)
        return s
    }
}


class SurfaceMix {
    /*
    Mix two Surfaces
       A       B     Mask   Output
    |-----| |-----| |-----| |-----|
    | a   | | b   | |OOOO/| | a  /|
    |     | |     | |OOO/ | |   / |
    |     |+|     |+|OO/  |=|  /  |
    |     | |     | |O/   | | /   |
    |   a | |   b | |/    | |/  b |
    |-----| |-----| |-----| |-----|
    A & B are mutated/modified/cut so they can be drawn to create the Output
    */
    constructor(surface_a, surface_b, mask) {
        this.a = surface_a
        this.b = surface_b
        this.mask = mask || new Surface(this.a.w, this.a.h)
        console.assert(Surface.isDimensionMatch(this.a, this.b), "Surfaces should match dimension")
        console.assert(Surface.isDimensionMatch(this.a, this.mask), "Mask should match Surface dimension")
    }
    cut() {
        this.a.c.save()
        this.a.c.globalCompositeOperation = 'destination-in';
        this.a.c.drawImage(this.mask.o, 0, 0)
        this.a.c.restore()
        this.b.c.save()
        this.b.c.globalCompositeOperation = 'destination-out';
        this.b.c.drawImage(this.mask.o, 0, 0)
        this.b.c.restore()
    }
}

class Font {
    constructor(img) {
        this.font = this._load_font_advance(img)
        this.char_cache = {}

        this.background = new Surface(8, 8)
        const bc = this.background.c
        bc.fillStyle='green'
        bc.fillRect(0, 0, img.width, img.height)
    }

    clear_cache() {
        clear_object(this.char_cache)
    }

    _load_font_advance(img) {
        const [w, h, seq] = [8, 8, SEQUENCE_DAMIENG]
        const [ww, hh] = [img.width, img.height]
        return Object.fromEntries(
            [...range(Math.min(Math.floor(ww/w)*Math.floor(hh/h),seq.length))].map((i)=>[
                seq[i], CanvasAnimationBase.subsurface(img, (i*w)%ww, Math.floor((i*w)/ww)*h, w, h)
            ])
        )
    }

    render_mask_img(mask, img) {
        const s = new Surface(mask.width, mask.height)
        s.c.drawImage(img, 0, 0)
        s.c.globalCompositeOperation = 'destination-in';
        s.c.drawImage(mask, 0, 0)
        return s.img
    }

    draw_char_mask(c, char, x, y) {
        let img
        if (!(img = this.char_cache[char])) {
            img = this.render_mask_img(this.font[char], this.background.o)
            this.char_cache[char] = img
        }
        c.drawImage(img, x, y)
    }

    draw_font(c, text, x, y) {
        for (let [i, char] of enumerate(text)) {
            this.draw_char_mask(c, char, x+i*8, y)
        }
    }
}


class FontCanvas extends CanvasAnimationBase {
    constructor() {
        super(undefined, 60, {background_color: 'black', width: 480, height: 270})
        this.a = Surface.fromCanvas(this.canvas)
        this.b = Surface.fromCanvas(this.canvas)
        this.mix = new SurfaceMix(this.a, this.b)
    }

    async constructor_async() {
        this.font = new Font(CanvasAnimationBase.invert(await this.load_image("font", "Babyteeth.webp")))
    }

    model_inc(frame) {
    }
    draw(context, frame) {

        this.font.clear_cache()
        const bc = this.font.background.c
        bc.fillStyle='green'; bc.fillRect(0,0,8,8);
        let f = Math.abs(Math.floor(Math.sin(frame/64)*15))
        CanvasAnimationBase.drawLine(bc,4+f%16,-4,-4,4+f%16,'#00FF00')

        this.a.clear()
        this.font.draw_font(this.a.c, "Hello, What is this! OMG OMG", 20, 20)

        this.b.clear()
        this.b.c.fillStyle='grey'
        this.b.c.fillRect(0,0,this.b.w,this.b.h)

        this.mix.mask.clear()
        this.mix.mask.c.fillStyle = 'white'
        this.mix.mask.c.fillRect(0,0,frame%this.w,this.h)

        this.mix.cut()

        this.clear()
        context.drawImage(this.a.o,0,0)
        context.drawImage(this.b.o,0,0)

        CanvasAnimationBase.drawLine(context, frame%this.w,0,frame%this.w,this.h,'white',4)
    }


}

const main = new FontCanvas()
await main.constructor_async()
main.setRunning(true)
</script></html>
