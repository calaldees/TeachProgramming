<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,....==" />
</head>
<body></body>
<script type="module">
import { enumerate, clear_object, fetch_text } from './core.js'
import { CanvasAnimationBase, Gfx } from './animation_base.js'
import { cut_font_chars_from_img, parse_font_unicode, SEQUENCE_DAMIENG } from './font_loader.js'

class Surface {
    constructor(width, height) {
        if (!(Number.isInteger(width) && Number.isInteger(height))) {debugger}
        console.assert(Number.isInteger(width) && Number.isInteger(height), "Surface must have int width/height")
        this.o = new OffscreenCanvas(width, height)
        this._c = this.o.getContext("2d")
        this._img = undefined
    }
    get w() {return this.o.width}
    get h() {return this.o.height}
    get c() {this._img = undefined; return this._c}
    get img() {return this._img || (this._img = this.o.transferToImageBitmap())}
    clear() {this.c.clearRect(0, 0, this.w, this.h)}
    static isDimensionMatch(a, b) {return a.w==b.w && a.h==b.h}
    static fromCanvas(canvas) {
        const s = new Surface(canvas.width, canvas.height)
        s.c.drawImage(canvas,0,0)
        return s
    }
}


class SurfaceMix {
    /*
    Mix two Surfaces
       A       B     Mask   Output
    |-----| |-----| |-----| |-----|
    | a   | | b   | |OOOO/| | a  /|
    |     | |     | |OOO/ | |   / |
    |     |+|     |+|OO/  |=|  /  |
    |     | |     | |O/   | | /   |
    |   a | |   b | |/    | |/  b |
    |-----| |-----| |-----| |-----|
    A & B are mutated/modified/cut so they can be drawn to create the Output
    */
    constructor(surface_a, surface_b, mask) {
        this.a = surface_a
        this.b = surface_b
        this.mask = mask || new Surface(this.a.w, this.a.h)
        console.assert(Surface.isDimensionMatch(this.a, this.b), "Surfaces should match dimension")
        console.assert(Surface.isDimensionMatch(this.a, this.mask), "Mask should match Surface dimension")
    }
    cut() {
        this.a.c.save()
        this.a.c.globalCompositeOperation = 'destination-in';
        this.a.c.drawImage(this.mask.o, 0, 0)
        this.a.c.restore()
        this.b.c.save()
        this.b.c.globalCompositeOperation = 'destination-out';
        this.b.c.drawImage(this.mask.o, 0, 0)
        this.b.c.restore()
    }
    cut_and_draw(context) {
        this.cut()
        context.drawImage(this.a.o,0,0)
        context.drawImage(this.b.o,0,0)
    }
}


class Font {
    constructor(font_char_img) {
        this.font = font_char_img
        this.char_cache = {}

        this.background = new Surface(8, 8)
        const bc = this.background.c
        bc.fillStyle='green'
        bc.fillRect(0, 0, bc.width, bc.height)
    }

    clear_cache() {
        clear_object(this.char_cache)
    }

    render_mask_img(mask, img) {
        const s = new Surface(mask.width, mask.height)
        s.c.save()
        s.c.drawImage(img, 0, 0)
        s.c.globalCompositeOperation = 'destination-in';
        s.c.drawImage(mask, 0, 0)
        s.c.restore()
        return s.img
    }

    draw_char_mask(c, char, x, y) {
        let img
        if (!(img = this.char_cache[char])) { // cache miss on font char
            img = this.render_mask_img(this.font[char], this.background.o)
            this.char_cache[char] = img
        }
        c.drawImage(img, x, y)
    }

    draw_font(c, text, x, y) {
        for (let [i, char] of enumerate(text)) {
            this.draw_char_mask(c, char, x+i*8, y)
        }
    }
}


class FontCanvas extends CanvasAnimationBase {
    constructor() {
        super(undefined, 60, {background_color: 'black', width: 480, height: 270})
        this.a = Surface.fromCanvas(this.canvas)
        this.b = Surface.fromCanvas(this.canvas)
        this.mix = new SurfaceMix(this.a, this.b)
    }

    async constructor_async() {
        this.font = new Font(cut_font_chars_from_img(Gfx.invert(await Gfx.load_image("Babyteeth.webp")), SEQUENCE_DAMIENG))
        this.font = new Font(await parse_font_unicode(await fetch_text('zx-spectrum.yaff')))
        //this.font2 = parse_font_text(fetch('amstrad_cpc.draw'))
        //this.font3 = parse_font_text(fetch('bbc_micro.yaff'))
    }

    model_inc(frame) {
    }
    draw(context, frame) {

        this.font.clear_cache()
        const bc = this.font.background.c
        bc.fillStyle='green'; bc.fillRect(0,0,8,8);
        let f = Math.abs(Math.floor(Math.sin(frame/64)*15))
        Gfx.drawLine(bc,4+f%16,-4,-4,4+f%16,'#00FF00')

        this.a.clear()
        this.font.draw_font(this.a.c, "Hello, What is this! OMG OMG", 20, 20)

        this.b.clear()
        this.b.c.fillStyle='grey'
        this.b.c.fillRect(0,0,this.b.w,this.b.h)

        this.mix.mask.clear()
        this.mix.mask.c.fillStyle = 'white'
        this.mix.mask.c.fillRect(0,0,frame%this.w,this.h)

        this.clear()
        this.mix.cut_and_draw(context)


        Gfx.drawLine(context, frame%this.w,0,frame%this.w,this.h,'white',4)
    }
}

const main = new FontCanvas()
await main.constructor_async()
main.setRunning(true)
</script></html>
