<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link id="favicon" rel="shortcut icon" type="image/png" href="data:image/png;base64,....==" />
</head>
<body></body>
<script type="module">
import {CanvasAnimationBase, Gfx} from './animation_base.js'

function* range(target, start=0, step=1) {for (let i=start ; i<target ; i+=step) {yield i}}


// https://paulbourke.net/geometry/pointlineplane/javascript.txt
// line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
// Determine the intersection point of two line segments - Return FALSE if the lines don't intersect
function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	// Check if none of the lines are of length 0
	if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {return false}
	const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))
	// Lines are parallel
	if (denominator === 0) {return false}
	const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
	const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator
	// is the intersection along the segments
	if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {return false}
	// Return a object with the x and y coordinates of the intersection
	return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)]  // return [x, y] of intersect point
}
function euclidean_distance(x1, y1, x2, y2) {
	return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)
}

const WALLS = [
    [150,150,160,150],
    [160,150,160,160],
    [160,160,150,160],
    [150,160,150,150],
]

class RaytraceDemo extends CanvasAnimationBase {
    constructor() {
        super(...arguments)
        this.x = 130
        this.y = 130
        this.camera_fov = Math.PI/2
        this.camera_angle = 0
        this.camera_draw_distance = 50
    }
    model_inc(frame) {
        if (this.keys_pressed.has('ArrowUp'))    {this.y += -1}
        if (this.keys_pressed.has('ArrowDown'))  {this.y +=  1}
        if (this.keys_pressed.has('ArrowLeft'))  {this.x += -1}
        if (this.keys_pressed.has('ArrowRight')) {this.x +=  1}
    }
    draw(context, frame) {
        this.clear()
        const c = context

        c.strokeStyle = 'white'
        for (let line of WALLS) {Gfx.drawLine(c,...line)}

        c.strokeStyle = 'green'
        c.fillStyle = 'green'
        const y_mid = this.h / 2

        const camera_pos = [this.x, this.y]
        const camera_angle_step_radians = this.camera_fov / this.w
        for (let x_draw of range(this.w)) {
            const ray_angle = this.camera_angle + (x_draw * camera_angle_step_radians)
            const ray_line = [
                ...camera_pos,
                this.x + Math.cos(ray_angle) * this.camera_draw_distance,
                this.y + Math.sin(ray_angle) * this.camera_draw_distance,
            ]
            //Gfx.drawLine(c,...ray_line)  // debug draw: the ray from observer
            //c.fillRect(ray_line[2],ray_line[3],1,1)  // debug draw: ray endpoint
            const ray_wall_intersect_points = WALLS
                .map(wall_line=>intersect(...wall_line, ...ray_line))
                .filter(p=>p)
                .sort((p1,p2)=>euclidean_distance(...camera_pos, ...p1) - euclidean_distance(...camera_pos, ...p2))
                //.filter((p, i)=>i==0)
                //.flat()
            //for (let p of pp) {c.fillRect(...p,1,1)}
            //console.log(pp)
            if (!ray_wall_intersect_points.length) {continue}  // nothing to draw for this `x_draw`
            const closest_intersect_point_to_camera = ray_wall_intersect_points[0]
            //c.fillRect(...closest_intersect_point_to_camera,1,1) // debug draw: intersect point to draw
            const distance_to_camera = Math.sqrt(euclidean_distance(...camera_pos, ...closest_intersect_point_to_camera))

            const line_height = (1/distance_to_camera) * this.h
            const d = Math.round((1-(distance_to_camera / this.camera_draw_distance)) * 255)
            c.strokeStyle = `rgba(${d},${d},${d},255)`
            Gfx.drawLine(c, x_draw, Math.round(y_mid+(line_height/2)), x_draw, Math.round(y_mid-(line_height/2)))
        }

        c.strokeStyle = 'red'
        c.fillStyle = 'red'
        c.fillRect(this.x,this.y,2,2)
    }
}
(await new RaytraceDemo()).setRunning(true)
</script></html>
