How to teach Computing
======================

* Spec given to students
    * Spec bingo -> tick + ask
* CheatSheet - encourage freely move between languages
* Projects for the year (in advance)
    * Autonomy and responsibility
        * Any order
        * Optional extensions (with indication of grade/skill/ability)
    * tackled in any language (see cheatSheet)
    * Lessons become consultations
    * Leverage peers
        * Code reviews
        * Pair programming
    * Theory covered by practical tasks
* Public repos
    * Version control
    * Transparency
* Automated tests
    * doctests
    * auto assessment to spec?
* Automated questions + answers
    * for individual
* Guided projects (bank of)
    * Actually create something
    * Sense of achievement
    * Accessible independently
    * [CDIO](https://en.wikipedia.org/wiki/CDIO_Initiative), context, real
* Theory guided by regular interleaving of exam questions on paper
* Sometimes don't even tell them what the lesson is about - just show them some code and Predict, Run, Investigate (PRIMM)
    * E.g. by ref or by val example
* Final self directed Personal project (A-level project)
    * Culmination of skills
    * Create a game?
    * Hardware? HCI? Output DMX?
* Meta-cognition (concept?)
    * Structured Retrospectives
    * Process + actions
* Group Wiki (concept?)
    * Publicly visible?
    * 'Who can' list?
* Peer Mentor (with a big enough and multiple generation group)
    * Learners are paired with (slightly) more experienced mentor
        * The course lead can pair appropriately by ability/personality
    * Have a 'Who can' list? direct students to each other for examples of identified practice.
    * Servant leadership
    * Could be external?
* Show cool relevant cultural stuff
    * Decentralisation
    * Snowden/Privacy
    * AI examples - Deepfakes?
        * https://experiments.withgoogle.com/collection/ai
        * https://machinelearningforkids.co.uk/
        * https://teachablemachine.withgoogle.com/
        * https://www.appsforgood.org/courses/machine-learning
* Hack time presentations (concept)
    * bring something cool?
    * Show feature/tool you've encountered
* Encourage participation at an event
    * HackDay
    * BarCamp (local tech culture meet/present)
    * Competitions (british informatics olympiad? robotics?)
* Real Exam (gcse or A-Level)
* Community
    * A 'hang' space
    * Learning though conversation
        * Challenging ideas
        * Consolidate learning/thinking

Continue someone elses project? games? add feature?
Take interest in their outside projects - showcase them? (like hack time presentations)
Role model?
Ownership of own learning

* [On a Metodology for Creating School Curricula in Computing](https://ioinformatics.org/journal/v11_2017_93_107.pdf)

* My preference is Teach algorithums at the _program level_
* [Teaching algorithms in upper secondary education: a study of teachers’ pedagogical content knowledge](https://www.tandfonline.com/doi/full/10.1080/08993408.2021.1935554)
    * >  introducing computing concepts without the use of a computer may keep “learners from the crucial computational experiences involved in CT’s common practice”
    * > “the ‘programming vs. Unplugged’ debate should not be an ‘either-or’ debate”
    * > assessment is often combined with a specific programming environment
        * overlap between object level and program level
    * > “students would be attracted by a feeling of recreation – in-the-moment enjoyment”
    * PCK - Magnusson et al. (1999)
        * knowledge of goals and objectives for teaching a specific topic in the curriculum, (GO)
        * knowledge of students’ understanding of this topic, (SU)
        * knowledge of instructional strategies concerning this topic, (IS)
        * knowledge of ways to assess students’ understanding of this topic (AS)
        * combinations of PKC in the form GO-IS
    * > It is about the analysis of a problem and what we need to come up with a solution … What we miss in secondary education is to first think about what is needed, what is the goal, how we get there, and what steps can be distinguished.
    * > too much focus on the syntax and distract from the problem-solving process. Futschek (2006) 

* Principles
    * Theory (lectures) _when needed_ and interesting dynamic
    * Creativity/Choice
        * Hard timetable, tasks are authoritative and hierarchical - this establish's a non desireable mode of thinking
    * Developer Culture/Community/Peer-network/collaboration
    * Low stakes at ALL stages
    * No competition / hierarchy / judgement
        * Their progress is under their own ownership
    * Participate in community
    * Convey principles/concepts over Tooling (be explicit about this to learners)
    * Real context/purpose, society focused
    * Consider emotional understand to foster engagement
        * [Emotions and programming learning: systematic mapping](https://www.tandfonline.com/doi/full/10.1080/08993408.2021.1920816)
        * Ellis and Tod - relationship with curriculum
    * Vancus 2009 - no reason to engage if no visible use for it
    * Wingfield and Eccles (1992) "Utility Value"

> Seymour Papert introduced the Logo language in the 1970s and watched how children got excited by computing and learned how to think computationally. He attuned Logo to children's interests; even so, it still took students time to move from the fascination of the introduction to the ability to program useful computations regularly.
https://cacm.acm.org/magazines/2017/3/213837-misconceptions-about-computer-science/fulltext


Thought - you cant just use someone else's resources
There are loads of good teaching resources out there. An entire planet of teachers creating and sharing resources. The reality is that people out their have (collectively) more experience and aught better than you ever could.
By they are not in your classroom with your students.
You could just say to your students 'you have the internet, go and learn about computer science'. But that wont work.
There is only one solution.
As a teacher, you need to do all these computing activities, you need to love something and make cool projects. You're understanding of the discipline and working though the problems is required.
It's not really possible to _use_ another teachers resources until you _understand_ them. And they only way to understand them is to complete them or create them.
Teachers need time to immerse themselves in the subject and explore. It's the only way they can be effective.


Investigate
* [Teaching and Learning with Jupyter](https://jupyter4edu.github.io/jupyter-edu-book/)

* [Code Reading Club](https://www.felienne.com/archives/6472)
    * Reading code is harder than writing code
    * We are VERY bad at teaching learners to read code

Partial programs (force read + understand)
Parson problems
Swap programs and add a feature to another persons codebase

> Barnett and Coate’s (2005) view of the curriculum in higher education as deliberately designed to engage students, among others. They write of
>> the imaginative design of spaces as such, spaces that are likely to generate new energies among students and inspire them, and so prompt their triple engagement – in knowing, acting and being. (3)

* [Maths e.g](http://www.mathcentre.ac.uk:8081/mathseg/index.jsp) - online site that individually programmatically generates questions and worked examples

TODO
See also CompterSciencePedagogy in teaching workshops
See also learning-to-code.md in mapOfComputing

Other
-----

* [First Year Computer Science Projects at Coventry University: Activity-led integrative team projects with continuous assessment](https://arxiv.org/abs/1911.11088)
    * > We describe the group projects undertaken by first year undergraduate Computer Science students at Coventry University. These are integrative course projects: designed to bring together the topics from the various modules students take, to apply them as a coherent whole. They follow an activity-led approach, with students given a loose brief and a lot of freedom in how to develop their project.
      > We outline the new regulations at Coventry University which eases the use of such integrative projects. We then describe our continuous assessment approach: where students earn a weekly mark by demonstrating progress to a teacher as an open presentation to the class. It involves a degree of self and peer assessment and allows for an assessment of group work that is both fair, and seen to be fair. It builds attendance, self-study / continuous engagement habits, public speaking / presentation skills, and rewards group members for making meaningful individual contributions. 
* [Learn proramming in 10 years](https://norvig.com/21-days.html)
    * Work on projects _with_ other programmers
    * Work on projects _after_ other programmers

* Parallels in MFL?
    * [Study shows exposure to multiple languages may make it easier to learn one](https://www.washington.edu/news/2019/09/05/study-shows-exposure-to-multiple-languages-may-make-it-easier-to-learn-one/)


* Assessment in PE
    * Idea - Could some of these techniqies be used to assess the qualitys we want to see in Computer science? Make them accessible? 
    * Physical
        * Fitness Level
        * Skills development
        * Tequnique
        * Decition Making
        * Competetive
    * Social
        * Communication
        * Movivation
        * Respect
        * Sportsmanship
        * Commitment
    * Leadership
        * Movtivation
        * Communiaton
        * Teamwork
        * Empathy and kindness
        * Cooperation
    * Coaching
        * Rules
        * Tactics
        * Technique
        * Use of terminology
        * Lead a warm up
