How to teach Computing
======================

* Spec given to students
    * Spec bingo -> tick + ask
* CheatSheet - encourage freely move between languages
* Projects for the year (in advance)
    * Autonomy and responsibility
        * Any order
        * Optional extensions (with indication of grade/skill/ability)
    * tackled in any language (see cheatSheet)
    * Lessons become consultations
    * Leverage peers
        * Code reviews
        * Pair programming
    * Theory covered by practical tasks
* Public repos
    * Version control
    * Transparency
* Automated tests
    * doctests
    * auto assessment to spec?
* Automated questions + answers
    * for individual
* Guided projects (bank of)
    * Actually create something
    * Sense of achievement
    * Accessible independently
* Theory guided by regular interleaving of exam questions on paper
* Sometimes don't even tell them what the lesson is about - just show them some code and Predict, Run, Investigate (PRIMM)
    * E.g. by ref or by val example
* Final self directed Personal project (A-level project)
    * Culmination of skills
    * Create a game?
    * Hardware? HCI? Output DMX?
* Meta-cognition (concept?)
    * Structured Retrospectives
    * Process + actions
* Group Wiki (concept?)
    * Publicly visible?
    * 'Who can' list?
* Peer Mentor (with a big enough and multiple generation group)
    * Learners are paired with (slightly) more experienced mentor
        * The course lead can pair appropriately by ability/personality
    * Have a 'Who can' list? direct students to each other for examples of identified practice.
    * Servant leadership
    * Could be external?
* Show cool relevant cultural stuff
    * Decentralisation
    * Snowden/Privacy
    * AI examples - Deepfakes?
* Hack time presentations (concept)
    * bring something cool?
    * Show feature/tool you've encountered
* Encourage participation at an event
    * HackDay
    * BarCamp (local tech culture meet/present)
    * Competitions (british informatics olympiad? robotics?)
* Real Exam (gcse or A-Level)
* Community
    * A 'hang' space
    * Learning though conversation
        * Challenging ideas
        * Consolidate learning/thinking

* Principles
    * Theory (lectures) _when needed_ and interesting dynamic
    * Creativity/Choice
        * Hard timetable, tasks are authoritative and hierarchical - this establish's a non desireable mode of thinking
    * Developer Culture/Community/Peer-network/collaboration
    * Low stakes at ALL stages
    * No competition / hierarchy / judgement
        * Their progress is under their own ownership
    * Participate in community
    * Convey principles/concepts over Tooling (be explicit about this to learners)


> Seymour Papert introduced the Logo language in the 1970s and watched how children got excited by computing and learned how to think computationally. He attuned Logo to children's interests; even so, it still took students time to move from the fascination of the introduction to the ability to program useful computations regularly.
https://cacm.acm.org/magazines/2017/3/213837-misconceptions-about-computer-science/fulltext


Investigate
* [Teaching and Learning with Jupyter](https://jupyter4edu.github.io/jupyter-edu-book/)

* [Code Reading Club](https://www.felienne.com/archives/6472)
    * Reading code is harder than writing code
    * We are VERY bad at teaching learners to read code

> Barnett and Coate’s (2005) view of the curriculum in higher education as deliberately designed to engage students, among others. They write of
>> the imaginative design of spaces as such, spaces that are likely to generate new energies among students and inspire them, and so prompt their triple engagement – in knowing, acting and being. (3)


TODO
See also CompterSciencePedagogy in teaching workshops
See also learning-to-code.md in mapOfComputing